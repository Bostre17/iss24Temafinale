System sprintzero

Dispatch goHome : goHome(X)				// comando da WIS per OpRobot di andare a HOME
Dispatch bringRP : bringRP(X)			// comando da WIS per OpRobot di andare a prendere RP in WASTEIN e portarlo in BURNIN
Dispatch bringAsh : bringAsh(X)			// comando da WIS per OpRobot di andare a prendere Ash in BURNOUT e portarlo in ASHOUT
Dispatch act : act(X)					// comando da WIS a Incinerator (Off = 0, On = 1, Idle = 2)
Dispatch ack : ack(X)					// messaggio di ack

Dispatch atIncinerator : atIncinerator(X) // messaggio da OpRobot a WIS quando arriva all'incinerator
Dispatch ashDeposited : ashDeposited(X)

Dispatch newRp : newRp(X)
Dispatch rpTaken : rpTaken(X)			// messaggio per scale

Dispatch newAsh : newAsh(X)
Dispatch emptyAsh : emptyAsh(X)

//Observable

Event burnEnd : burnEnd(BTIME)
Event stateScale : stateScale(X) 			// messaggio observable update valore scale
Event stateSonar : stateSonar(X)			// messaggio observable update valore sonar
//Event position : position(X,Y,J)				// messaggio observable posizione oprobot

// messaggi conversazione engage tra OpRobot e BasicRobot
Request  engage : engage(OWNER, STEPTIME)
Reply engagedone : engagedone(ARG) for engage
Reply engagerefused : engagerefused(ARG) for engage
Dispatch disengage    : disengage(ARG)

Request moverobot : moverobot(X,Y)
Reply moverobotdone : moverobotdone(X) for moverobot
Reply moverobotfailed : moverobotfailed(X) for moverobot




Context ctxwis ip [host="localhost" port=8001]
//con 8020 qualche messaggio arriva al basicrobot: dovrebbe essere la porta giusta
Context ctxbasicrobot ip [host="127.0.0.1" port=8020]

ExternalQActor basicrobot context ctxbasicrobot





//--------------------------Incinerator-----------------------------

QActor incinerator context ctxwis {
	//(Off = 0, On = 1, Idle = 2)
    [#
    	val Btime = 10L
    	var state = 0
    #]
	State off initial{
		println("[$name] waiting for activation") color magenta
	}
	Transition t0 whenMsg act -> handleAct
	
	State handleAct{
		//in ricezione di una forward, deve essere raggruppato da onMsg() altrimenti da errore 
		//	java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0
		onMsg(act : act(X)) {
			println("[$name] act ricevuto") color magenta
			[# state = payloadArg(0).toInt()#]
			println("[$name] act letto") color magenta
		}
	} 
	Goto burn if [# state == 1 #] else idle

	
	State idle{
		println("[$name] idle") color magenta
	}
	Transition t0 whenMsg act -> handleAct
			
	State burn{
		println("[$name] on") color magenta
		[#
			delay(Btime*1000)
			state = 2	
		#]
		emit burnEnd : burnEnd($Btime)
		updateResource [# "burnEnd(${Btime})" #]
	}
	Goto idle
}



//--------------------------Scale-----------------------------
//è fatto per test interni, poi sicuramente va cambiato.
QActor scalemock context ctxwis {
	[#
		var WEIGHT = 0	
	#]
	
	State s0 initial {
		println("[$name] inizializzazione.") color red
		delay 10000
		[# WEIGHT = 100#]
		emitlocalstream stateScale : stateScale($WEIGHT)
		println("[$name] stateScale updated a $WEIGHT.") color red
    }
    Transition t0 whenMsg rpTaken -> handleRpTaken
    
    State handleRpTaken{
    	[# WEIGHT -= 50 #]
    	if [# WEIGHT < 0#]
        {
            [# WEIGHT = 0#]
        }
		emitlocalstream stateScale : stateScale($WEIGHT)
		println("[$name] stateScale updated a $WEIGHT.") color red
    }
    Transition t0	whenMsg rpTaken -> handleRpTaken
    				whenMsg newRp -> handleNewRp
    				
    State handleNewRp{
        [# WEIGHT += 50#]
		println("[$name] RP aggiunto. stateScale updated a $WEIGHT.") color red
    }
    Transition t0	whenMsg rpTaken -> handleRpTaken
    				whenMsg newRp -> handleNewRp
}

//-------------------------- Mocks --------------------------
QActor sonarmock context ctxwis{
    [#var DISTANCE=200#]
    State s0 initial{
        println("[$name] inizializzazione.") color red
		delay 5000
		println("[$name] stateSonar updated a $DISTANCE.") color red
		emitlocalstream stateSonar : stateSonar($DISTANCE)
    }
    Transition t0 	whenMsg newAsh -> handleNewAsh
                    whenMsg emptyAsh -> handleEmptyAsh

    State handleNewAsh{
        [#DISTANCE = DISTANCE - 60#]
        if [# DISTANCE < 0#]
        {
            [# DISTANCE = 0#]
        }
		println("[$name] stateSonar updated a $DISTANCE.") color red
        emitlocalstream stateSonar : stateSonar($DISTANCE)
    }
    Transition t0	whenMsg newAsh -> handleNewAsh
                    whenMsg emptyAsh -> handleEmptyAsh

    State handleEmptyAsh{
        [#DISTANCE = 200#]
		println("[$name] ashes svuotate. stateSonar updated a $DISTANCE.") color red
    }
    Transition t0	whenMsg newAsh -> handleNewAsh
                    whenMsg emptyAsh -> handleEmptyAsh
}




//--------------------------OpRobot-----------------------------

QActor oprobot context ctxwis {
	
	[#
		val pos: MutableMap<String, Array<String>> = mutableMapOf()
	    pos["home"] = arrayOf("0", "0")
	    pos["burnin"] = arrayOf("2", "1")
	    pos["burnout"] = arrayOf("4", "3")
		pos["ashout"] = arrayOf("5", "4")
		pos["wastein"] = arrayOf("0", "4")
		var X="0"
		var Y="0"
		var Xfut = "0"
		var Yfut = "0"
		var Job=""
	#]

    State s0 initial {
	    println("[$name] inizializzazione.") color yellow
	}
	Goto tryEngage
	
	
	// Stato che tenta di stabilire la connessione con il BasicRobot
	State tryEngage {
	    println("[$name] tentativo engage a BasicRobot...") color yellow
	    
	    request basicrobot -m engage : engage(name, 330)
        println("[$name] richiesta di engage inviata al basicrobot") color yellow
	}
	Transition t0 whenTime 1000         	-> noReply
	              whenReply engagedone   	-> standby
	
	
	// Stato che gestisce l'assenza di risposta
	State noReply {
	    println("[$name] nessuna risposta da BasicRobot: failed.") color yellow
	}
	
	// Stato in attesa di ricevere un compito
	State standby {
	    println("[$name] pronto e in attesa in HOME.") color yellow
	    [#
			X= pos["home"]!!.get(0)
			Y= pos["home"]!!.get(1)
			Job="Waiting Home"
		#]
		//emitlocalstream position : position($X,$Y,$Job)
	}
	Transition t1 	whenMsg bringRP -> goWasteIn
					whenMsg bringAsh -> goBurnOut
	
	
	State goWasteIn {
	    println("[$name] vado in WasteIn.") color yellow
		[#
			X = pos["wastein"]!!.get(0)
			Y = pos["wastein"]!!.get(1)
		#]
		request basicrobot -m moverobot : moverobot($X,$Y)
	} 
	Transition t2 whenReply moverobotdone -> goBurnIn
				  whenReply moverobotfailed -> goHome
	
	State goBurnIn {
	    println("[$name] arrivato in WasteIn.") color yellow
		[#
			Job = "In WasteIn"
		#]
		//emitlocalstream position : position($X,$Y,$Job)
		
		forward scalemock -m rpTaken : rpTaken(1)
	    println("[$name] RP prelevato.") color yellow
		
		[#
			X = pos["burnin"]!!.get(0)
			Y = pos["burnin"]!!.get(1)
		#]
	    println("[$name] vado in BurnIn.") color yellow
		request basicrobot -m moverobot : moverobot($X,$Y)
		
	} 
	Transition t3 whenReply moverobotdone -> arrivedToIncinerator
				  whenReply moverobotfailed -> goHome
	
	State arrivedToIncinerator {
	    println("[$name] sono arrivato all'incinerator.") color yellow
		[#
			Job = "Waiting in BurnIn"
		#]
		//emitlocalstream position : position($X,$Y,$Job)
		
		forward wis -m atIncinerator : atIncinerator(X)
		
		delay 1000
	}
	Transition t4 whenMsg goHome -> goHome
	
	State goHome {
		
		if [# Job != "Waiting Home"#]
		{
		    println("[$name] vado in HOME.") color yellow
			[#
				Job = "Going Home"
			#]
			//emitlocalstream position : position($X,$Y,$Job)
			
			[#
				X= pos["home"]!!.get(0)
				Y= pos["home"]!!.get(1)	
			#]
			request basicrobot -m moverobot : moverobot($X,$Y)
		}
		else
		{
		    println("[$name] sono gia' in HOME.") color yellow
		}
		
	} 
	Transition t5 whenReply moverobotdone -> standby
				  whenReply moverobotfailed -> goHome
				  
	
	State goBurnOut {
	    println("[$name] vado a prelevare le ash in BurnOut.") color yellow
		[#
			Job = "Going BurnOut"
		#]
		//emitlocalstream position : position($X,$Y,$Job)
		
		[#
			X= pos["burnout"]!!.get(0)
			Y= pos["burnout"]!!.get(1)
		#]
		request basicrobot -m moverobot : moverobot($X,$Y)
	}
	Transition t6 whenReply moverobotdone -> goAshOut
				  whenReply moverobotfailed -> goHome
	
	State goAshOut {
	    println("[$name] sono arrivato in BurnOut.") color yellow
		[#
			Job = "In BurnOut"
		#]
		//emitlocalstream position : position($X,$Y,$Job)
		
		[#
			X= pos["ashout"]!!.get(0)
			Y= pos["ashout"]!!.get(1)
		#]
	    println("[$name] vado a depositare le ash in AshOut.") color yellow
		request basicrobot -m moverobot : moverobot($X,$Y)
	}
	Transition t7 whenReply moverobotdone -> atAshStorage
				  whenReply moverobotfailed -> goHome
	
	State atAshStorage {
	    println("[$name] sono arrivato in AshStorage.") color yellow
		[#
			Job = "Depositing Ashes in AshStorage"
		#]
		//emitlocalstream position : position($X,$Y,$Job)
		
		delay 2000
		
		forward sonarmock -m newAsh : newAsh(X)
		
	    println("[$name] ho depositato le ash: notifico il wis.") color yellow
	    
	    forward wis -m ashDeposited : ashDeposited(X)
		
		
	} //Quando deposita le ash, in base a verify condition del wis, l'oprobot torna a home o wastein.
	Transition t8 	whenMsg goHome -> goHome
					whenMsg bringRP -> goWasteIn
				  
}



//--------------------------WIS-----------------------------

QActor wis context ctxwis {
	[#
	val DLIMT = 5
	var wasteStorageWeight=0
	var ashStorageLevel = 0
	var posX = 0
	var posY = 0
	var incinerator = 0
	var job = ""
	var RP=0
	var INC = 2
	#]
	
	
    State s0 initial {
        println("[$name] Initializing system") color green
        
        subscribeTo incinerator for burnEnd 
		subscribeTo scalemock for stateScale
		subscribeTo sonarmock for stateSonar
		//subscribeTo oprobot for position
		
        //incinerator idle (Off = 0, On = 1, Idle = 2)
        //le variabili inviate devono essere TUTTE MAIUSCOLE e raggruppare in ricezione con onMsg()
        forward incinerator -m act : act($INC)
        println("[$name] sent act to incinerator") color green
        [# incinerator = 2 #]
    }
    Goto waitingRP


    State waitingRP {
        println("[$name] waiting for RP") color green
        forward oprobot -m goHome : goHome(X)
        println("[$name] inviato goHome ad oprobot.") color green
    }
	Transition t0
		whenEvent stateScale -> verifyCondition
		whenEvent stateSonar -> verifyCondition
	
	
	
	
	State verifyCondition{
		printCurrentMessage
		println("[DEBUG $name] RP=$RP, incineratorState=$incinerator, ashStorageLevel=$ashStorageLevel")
		onMsg( stateSonar : stateSonar(X)){
			[# ashStorageLevel = payloadArg(0).toInt() #]
			println("[$name] Ash storage level updated: $ashStorageLevel") color green
		}
		onMsg( stateScale : stateScale(X)){
			[# 	wasteStorageWeight = payloadArg(0).toInt() 
				 RP = wasteStorageWeight/50 #]
			println("[$name] RP quantity updated: $RP") color green
		}
	}
	Goto startRoutine if [#RP>0 && incinerator!=1 && ashStorageLevel > DLIMT#] else waitingRP
			
    
    
    
    State startRoutine{
    	println("[$name] start routine") color green
    	forward oprobot -m bringRP : bringRP(X)
    }
    Transition t0
    	whenMsg atIncinerator -> startIncinerator
		whenInterruptEvent stateScale -> handleStateScale
		whenInterruptEvent stateSonar -> handleStateSonar
		//whenInterruptEvent position -> handleRobotPosition
		
    
    State startIncinerator{
        println("[$name] Incinerator started") color green
        forward incinerator -m act : act(1)
        // il robot potrebbe tornare in home da solo senza comando del wis, però se non facessi così tornerebbe ad home istantaneamente, senza scaricare RP (su controllo del WIS)
        forward oprobot -m goHome : goHome(X)
        [# incinerator = 1#]
	}
	Transition t0
		whenEvent burnEnd -> endIncinerator
		whenInterruptEvent stateScale -> handleStateScale
		whenInterruptEvent stateSonar -> handleStateSonar
		//whenInterruptEvent position -> handleRobotPosition
	
	State endIncinerator{
        println("[$name] incinerator is now idle") color green
        forward oprobot -m bringAsh : bringAsh(X)
    	[# 
    		incinerator = 2
    	#]

	}
	Transition t0
		whenMsg ashDeposited -> verifyCondition
		whenInterruptEvent stateScale -> handleStateScale
		whenInterruptEvent stateSonar -> handleStateSonar
		//whenInterruptEvent position -> handleRobotPosition
    
    
    //State handleStateIncinerator {
    //    onMsg( stateIncinerator : stateIncinerator(X)){
	//		[# incinerator = payloadArg(0).toInt() #]
	//		println("Incinerator state (Off = 0, On = 1, Idle = 2): $incinerator") color green
	//	}
	//	returnFromInterrupt
    //}
    
    State handleStateSonar {
        onMsg( stateSonar : stateSonar(X)){
			[# ashStorageLevel = payloadArg(0).toInt() #]
			println("[$name] Ash storage level updated: $ashStorageLevel") color green
		}
		returnFromInterrupt
    }
    
    State handleStateScale {
        onMsg( stateScale : stateScale(X)){
			[# 	wasteStorageWeight = payloadArg(0).toInt() 
				RP = wasteStorageWeight/50 #]
			println("[$name] RP quantity updated: $RP") color green
		}
		returnFromInterrupt
    }
    /* 
    State handleRobotPosition {
        onMsg( position : position(X,Y)){
			[# 	posX = payloadArg(0).toInt()
				posY = payloadArg(1).toInt() 
				job = payloadArg(2)
			#]
			println("[$name] OpRobot   position $posX $posY   routine $job") color green
		}
		returnFromInterrupt
    }
    */
}