System sprintzero

Dispatch goHome : goHome(X)				// comando da WIS per OpRobot di andare a HOME
Dispatch bringRP : bringRP(X)			// comando da WIS per OpRobot di andare a prendere RP in WASTEIN e portarlo in BURNIN
Dispatch bringAsh : bringAsh(X)			// comando da WIS per OpRobot di andare a prendere Ash in BURNOUT e portarlo in ASHOUT
Dispatch act : act(X)					// comando di accensione iniziale dell'incinerator
Dispatch notifyRp : notifyRp(x)			// messaggio di notifica presenza RP presso BURNIN
Dispatch ack : ack(X)					// messaggio di ack

Dispatch atIncinerator : atIncinerator(X) // messaggio da OpRobot a WIS quando arriva all'incinerator
Dispatch ashDeposited : ashDeposited(X)

Dispatch newRp : newRp(X)
Dispatch rpTaken : rpTaken(X)			// messaggio per scale

Dispatch newAsh : newAsh(X)
Dispatch emptyAsh : emptyAsh(X)

//Observable

Event burnEnd : burnEnd(BTIME)
Event stateScale : stateScale(X) 			// messaggio observable update valore scale
Event stateSonar : stateSonar(X)			// messaggio observable update valore sonar
//Event position : position(X,Y,J)				// messaggio observable posizione oprobot

// messaggi conversazione engage tra OpRobot e BasicRobot
Request  engage : engage(OWNER, STEPTIME)
Reply engagedone : engagedone(ARG) for engage
Reply engagerefused : engagerefused(ARG) for engage
Dispatch disengage    : disengage(ARG)

Request moverobot : moverobot(X,Y)
Reply moverobotdone : moverobotdone(X) for moverobot
Reply moverobotfailed : moverobotfailed(X) for moverobot




Context ctxwis ip [host="localhost" port=8001]
//con 8020 qualche messaggio arriva al basicrobot: dovrebbe essere la porta giusta
Context ctxbasicrobot ip [host="127.0.0.1" port=8020]

ExternalQActor basicrobot context ctxbasicrobot





//--------------------------Incinerator-----------------------------

QActor incinerator context ctxwis {
	//(Off = 0, On = 1, Idle = 2)
    [#
    	val Btime = 10L
    	var state = 0
    #]
	State off initial{
		println("[$name] waiting for activation") color magenta
	}
	Transition t0 whenMsg act -> handleAct
	
	State handleAct{
		//in ricezione di una forward, deve essere raggruppato da onMsg() altrimenti da errore 
		//	java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0
		onMsg(act : act(X)) {
			println("[$name] act ricevuto") color magenta
			[# state = payloadArg(0).toInt()#]
			println("[$name] act letto") color magenta
		}
	} 
	Goto idle

	State idle{
		println("[$name] idle") color magenta
	}
	Transition t0 whenMsg notifyRp -> handleRp
			
	State handleRp{
		//in ricezione di una forward, deve essere raggruppato da onMsg() altrimenti da errore 
		//	java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0
		onMsg(act : act(X)) {
			println("[$name] notifyRp ricevuto") color magenta
			[# state = payloadArg(0).toInt()#]
			println("[$name] notifyRp letto") color magenta
		}
	} 
	Goto burn
	
	State burn{
		println("[$name] on") color magenta
		[#
			delay(Btime*1000)
			state = 2	
		#]
		emit burnEnd : burnEnd($Btime)
		updateResource [# "burnEnd(${Btime})" #]
	}
	Goto idle
}



//--------------------------Scale-----------------------------
//è fatto per test interni, poi sicuramente va cambiato.
QActor scalemock context ctxwis {
	[#
		var WEIGHT = 0	
	#]
	
	State s0 initial {
		println("[$name] inizializzazione.") color red
		delay 10000
		[# WEIGHT = 100#]
		emitlocalstream stateScale : stateScale($WEIGHT)
		println("[$name] stateScale updated a $WEIGHT.") color red
    }
    Transition t0 whenMsg rpTaken -> handleRpTaken
    
    State handleRpTaken{
    	[# WEIGHT -= 50 #]
    	if [# WEIGHT < 0#]
        {
            [# WEIGHT = 0#]
        }
		emitlocalstream stateScale : stateScale($WEIGHT)
		println("[$name] stateScale updated a $WEIGHT.") color red
    }
    Transition t0	whenMsg rpTaken -> handleRpTaken
    				whenMsg newRp -> handleNewRp
    				
    State handleNewRp{
        [# WEIGHT += 50#]
		println("[$name] RP aggiunto. stateScale updated a $WEIGHT.") color red
    }
    Transition t0	whenMsg rpTaken -> handleRpTaken
    				whenMsg newRp -> handleNewRp
}

//-------------------------- Mocks --------------------------
QActor sonarmock context ctxwis{
    [#var DISTANCE=200#]
    State s0 initial{
        println("[$name] inizializzazione.") color red
		delay 5000
		println("[$name] stateSonar updated a $DISTANCE.") color red
		emitlocalstream stateSonar : stateSonar($DISTANCE)
    }
    Transition t0 	whenMsg newAsh -> handleNewAsh
                    whenMsg emptyAsh -> handleEmptyAsh

    State handleNewAsh{
        [#DISTANCE = DISTANCE - 60#]
        if [# DISTANCE < 0#]
        {
            [# DISTANCE = 0#]
        }
		println("[$name] stateSonar updated a $DISTANCE.") color red
        emitlocalstream stateSonar : stateSonar($DISTANCE)
    }
    Transition t0	whenMsg newAsh -> handleNewAsh
                    whenMsg emptyAsh -> handleEmptyAsh

    State handleEmptyAsh{
        [#DISTANCE = 200#]
		println("[$name] ashes svuotate. stateSonar updated a $DISTANCE.") color red
    }
    Transition t0	whenMsg newAsh -> handleNewAsh
                    whenMsg emptyAsh -> handleEmptyAsh
}


//cambiamenti al robot per limitare comunicazione con wis, passo at incinerator senza variabile X ma solo per conferma.
//giusto per comunicare che l'azione è  stata effettuata
//se arriva un nuovo lavoro lo esegue subito senza tornare a casa
//tolto pos da home e tolta logica si conferma engage secondo me ridondante
//dall'incenerator può effettuare altri ordini in coda senza incepparsi aggiungendo condizioni in t4

//--------------------------OpRobot-----------------------------

QActor oprobot context ctxwis {
	[#
		val pos: MutableMap<String, Array<String>> = mutableMapOf()
	    pos["home"] = arrayOf("0", "0")
	    pos["burnin"] = arrayOf("2", "1")
	    pos["burnout"] = arrayOf("4", "3")
		pos["ashout"] = arrayOf("5", "4")
		pos["wastein"] = arrayOf("0", "4")

		var Job=""
	#]
    

    State s0 initial {
        println("[$name] inizializzazione.") color yellow
        request basicrobot -m engage : engage(name, 330)
    }
    Transition t0 whenReply engagedone -> standby
    
    State standby {
        println("[$name] pronto e in attesa in HOME.") color yellow
        [# Job = "Waiting Home" #]
    }
    Transition t1 whenMsg bringRP -> goWasteIn
                  whenMsg bringAsh -> goBurnOut
    
    State goWasteIn {
        println("[$name] vado in WasteIn.") color yellow
        [# 
        	val X = pos["wastein"]!!.get(0); 
        	val Y = pos["wastein"]!!.get(1)
        #]
        request basicrobot -m moverobot : moverobot($X,$Y)
    } 
    Transition t2 whenReply moverobotdone -> goBurnIn
                  whenReply moverobotfailed -> goHome

    State goBurnIn {
        println("[$name] arrivato in WasteIn, vado in BurnIn.") color yellow
        [# Job = "In WasteIn" #]
        forward scalemock -m rpTaken : rpTaken(1)
        [# 
        	val X = pos["burnin"]!!.get(0); 
        	val Y = pos["burnin"]!!.get(1) 
        #]
        request basicrobot -m moverobot : moverobot($X,$Y)
    } 
    Transition t3 whenReply moverobotdone -> arrivedToIncinerator
                  whenReply moverobotfailed -> goHome
    
    State arrivedToIncinerator {
        println("[$name] sono arrivato all'inceneritore e notifico.") color yellow
        [# Job = "Waiting in BurnIn" #]
        forward wis -m atIncinerator : atIncinerator(1)
    }
    Transition t4 whenMsg goHome -> goHome
                  whenMsg bringAsh -> goBurnOut
                  whenMsg bringRP -> goWasteIn

   	State goHome {
   		if [# Job != "Waiting Home"#] {
        	println("[$name] vado in HOME.") color yellow
        	[# Job = "Going Home" #]
        	[# 
        		val X = pos["home"]!!.get(0); 
        		val Y = pos["home"]!!.get(1) 
        	#]
        	request basicrobot -m moverobot : moverobot($X,$Y)
    	} else {
        	println("[$name] sono gia' in HOME.") color yellow
    	}
    // Se è già in HOME, deve comunque passare a standby per accettare nuovi comandi
    // Lo facciamo con un 'Goto' incondizionato DENTRO l'else.
   	}
  	Goto standby if [# Job == "Waiting Home" #] else waitForReply

   //stato intermedio per attendere la risposta perchè sennò può essere che non va in standby
	State waitForReply{
  		println("[$name] In attesa di arrivare a HOME...") color yellow
  	}
	Transition t5 whenReply moverobotdone -> standby
              whenReply moverobotfailed -> goHome
                  
    State goBurnOut {
        println("[$name] vado a prelevare le ash in BurnOut.") color yellow
        [# Job = "Going BurnOut" #]
        [# 
        	val X = pos["burnout"]!!.get(0); 
        	val Y = pos["burnout"]!!.get(1) 
        #]
        request basicrobot -m moverobot : moverobot($X,$Y)
    }
    Transition t6 whenReply moverobotdone -> goAshOut
                  whenReply moverobotfailed -> goHome
    
    State goAshOut {
        println("[$name] arrivato in BurnOut, vado a depositare in AshOut.") color yellow
        [# Job = "In BurnOut" #]
        [# 
        	val X = pos["ashout"]!!.get(0); 
        	val Y = pos["ashout"]!!.get(1)
        	 
        #]
        request basicrobot -m moverobot : moverobot($X,$Y)
    }
    Transition t7 whenReply moverobotdone -> atAshStorage
                  whenReply moverobotfailed -> goHome
    
    State atAshStorage {
        println("[$name] arrivato in AshStorage, deposito e notifico.") color yellow
        [# Job = "Depositing Ashes" #]
        forward sonarmock -m newAsh : newAsh(1)
        forward wis -m ashDeposited : ashDeposited(1)
    }
    Transition t8 whenMsg goHome -> goHome
                  whenMsg bringRP -> goWasteIn
}


//--------------------------WIS-----------------------------

QActor wis context ctxwis {
	[#
	val DLIMT = 5
	var wasteStorageWeight=0
	var ashStorageLevel = 0
	var posX = 0
	var posY = 0
	var incinerator = 0
	var job = ""
	var RP=0
	#]
	
	
    State s0 initial {
        println("[$name] Initializing system") color green
        
        subscribeTo incinerator for burnEnd 
		subscribeTo scalemock for stateScale
		subscribeTo sonarmock for stateSonar
		//subscribeTo oprobot for position
		
        //le variabili inviate devono essere TUTTE MAIUSCOLE e raggruppare in ricezione con onMsg()
        forward incinerator -m act : act(2)
        println("[$name] sent act to incinerator") color green
        [# incinerator = 2 #]
    }
    Goto waitingRP


    State waitingRP {
        println("[$name] waiting for RP") color green
        forward oprobot -m goHome : goHome(X)
        println("[$name] inviato goHome ad oprobot.") color green
    }
	Transition t0
		whenEvent stateScale -> verifyCondition
		whenEvent stateSonar -> verifyCondition
	
	
	
	
	State verifyCondition{
		printCurrentMessage
		println("[DEBUG $name] RP=$RP, incineratorState=$incinerator, ashStorageLevel=$ashStorageLevel")
		onMsg( stateSonar : stateSonar(X)){
			[# ashStorageLevel = payloadArg(0).toInt() #]
			println("[$name] Ash storage level updated: $ashStorageLevel") color green
		}
		onMsg( stateScale : stateScale(X)){
			[# 	wasteStorageWeight = payloadArg(0).toInt() 
				 RP = wasteStorageWeight/50 #]
			println("[$name] RP quantity updated: $RP") color green
		}
	}
	Goto startRoutine if [#RP>0 && incinerator!=1 && ashStorageLevel > DLIMT#] else waitingRP
			
    
    
    
    State startRoutine{
    	println("[$name] start routine") color green
    	forward oprobot -m bringRP : bringRP(X)
    }
    Transition t0
    	whenMsg atIncinerator -> startIncinerator
		whenInterruptEvent stateScale -> handleStateScale
		whenInterruptEvent stateSonar -> handleStateSonar
		//whenInterruptEvent position -> handleRobotPosition
		
    
    State startIncinerator{
        println("[$name] Incinerator started") color green
        forward incinerator -m notifyRp : notifyRp(X)
        // il robot potrebbe tornare in home da solo senza comando del wis, però se non facessi così tornerebbe ad home istantaneamente, senza scaricare RP (su controllo del WIS)
        forward oprobot -m goHome : goHome(X)
        [# incinerator = 1#]
	}
	Transition t0
		whenEvent burnEnd -> endIncinerator
		whenInterruptEvent stateScale -> handleStateScale
		whenInterruptEvent stateSonar -> handleStateSonar
		//whenInterruptEvent position -> handleRobotPosition
	
	State endIncinerator{
        println("[$name] incinerator is now idle") color green
        forward oprobot -m bringAsh : bringAsh(X)
    	[# 
    		incinerator = 2
    	#]

	}
	Transition t0
		whenMsg ashDeposited -> verifyCondition
		whenInterruptEvent stateScale -> handleStateScale
		whenInterruptEvent stateSonar -> handleStateSonar
		//whenInterruptEvent position -> handleRobotPosition
    
    
    //State handleStateIncinerator {
    //    onMsg( stateIncinerator : stateIncinerator(X)){
	//		[# incinerator = payloadArg(0).toInt() #]
	//		println("Incinerator state (Off = 0, On = 1, Idle = 2): $incinerator") color green
	//	}
	//	returnFromInterrupt
    //}
    
    State handleStateSonar {
        onMsg( stateSonar : stateSonar(X)){
			[# ashStorageLevel = payloadArg(0).toInt() #]
			println("[$name] Ash storage level updated: $ashStorageLevel") color green
		}
		returnFromInterrupt
    }
    
    State handleStateScale {
        onMsg( stateScale : stateScale(X)){
			[# 	wasteStorageWeight = payloadArg(0).toInt() 
				RP = wasteStorageWeight/50 #]
			println("[$name] RP quantity updated: $RP") color green
		}
		returnFromInterrupt
    }
    /* 
    State handleRobotPosition {
        onMsg( position : position(X,Y)){
			[# 	posX = payloadArg(0).toInt()
				posY = payloadArg(1).toInt() 
				job = payloadArg(2)
			#]
			println("[$name] OpRobot   position $posX $posY   routine $job") color green
		}
		returnFromInterrupt
    }
    */
}