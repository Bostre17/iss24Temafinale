System sprintzero

Dispatch goHome : goHome(X)				// comando da WIS per OpRobot di andare a HOME
Dispatch bringRP : bringRP(X)			// comando da WIS per OpRobot di andare a prendere RP in WASTEIN e portarlo in BURNIN
Dispatch bringAsh : bringAsh(X)			// comando da WIS per OpRobot di andare a prendere Ash in BURNOUT e portarlo in ASHOUT
Dispatch act : act(X)					// comando di attivazione da WIS a Incinerator (Off = 0, On = 1, Idle = 2)
Dispatch burn : burn(X)					// comando di accensione inceneritore da WIS a Incinerator 


//Observable

Dispatch stateScale : 222(X) 			// messaggio observable update valore scale
Dispatch stateSonar : updateSonar(x)			// messaggio observable update valore sonar
Dispatch position : position(X,Y)					// messaggio observable posizione oprobot
Dispatch stateIncinerator : stateIncinerator(X)	// messaggio observable stato incinerator


Event burnEnd : burnEnd(BTIME)


Context ctxwis ip [host="localhost" port=8001]
Context ctxscale ip [host="localhost" port=8002]
Context ctxsonar ip [host="localhost" port=8003]
Context ctxbasicrobot ip [host="127.0.0.1" port=8001]

ExternalQActor ddr_robot context ctxbasicrobot




//--------------------------WIS-----------------------------

QActor wis context ctxwis {
	[#
	val DLIMT = 5
	var wasteStorageWeight=0;
	var ashStorageLevel = 0;
	var posX = 0;
	var posY = 0;
	var stateIncinerator = 0;
	#]

    State s0 initial {
        println("WIS: Initializing system") color green
        //incinerator idle (Off = 0, On = 1, Idle = 2)
        forward incinerator -m act : act(2)
    }
    Goto waitingRP

    State waitingRP {
        println("WIS: Waiting for RP") color green
    }
	Transition t0 	
		whenEvent burnEnd -> endIncinerator
		whenMsg stateScale -> handleStateScale
		whenMsg stateSonar -> handleStateSonar
		whenMsg position -> position
		whenMsg stateIncinerator -> handleStateIncinerator
		
    State handleStateSonar {
        println("WIS: Updating ash level") color green
        onMsg( stateSonar : stateSonar(X)){
			[# ashStorageLevel = payloadArg(0).toInt() #]
			println("Ash storage level updated: $ashStorageLevel") color green
		}
    }
    Goto waitingRP
    
    State handleStateScale {
        println("WIS: Updating number of RP") color green
        onMsg( stateScale : stateScale(X)){
			[# 	wasteStorageWeight = payloadArg(0).toInt() 
				var RP = wasteStorageWeight/50
			#]
			println("RP quantity updated: $RP") color green
		}
    }
    Goto waitingRP
    
    State position {
        println("WIS: Updating the OpRobot status") color green
        onMsg( position : position(X,Y)){
			[# 	posX = payloadArg(0).toInt()
				posY = payloadArg(1).toInt()
			#]
			println("OpRobot position updated: $posX $posY") color green
		}
	
    }
    Goto waitingRP
    
    State handleStateIncinerator {
        println("WIS: Updating ash level") color green
        onMsg( stateIncinerator : stateIncinerator(X)){
			[# 	
				stateIncinerator = payloadArg(0).toInt()
			#]
			println("Incinerator state updated: $stateIncinerator") color green
		}
    }
    Goto waitingRP
    
    
    
    
	State startIncenerator{
		[#//INCENERATOR = true#]
        println("WIS: Incinerator started") color green
	}
	Goto idle
	
	State endIncinerator{
		[#//INCENERATOR = false#]
        println("WIS: Incinerator ended") color green
	}
	Goto idle
}





//--------------------------OpRobot-----------------------------

QActor oprobot context ctxwis {

    State s0 initial {
        println("$name attivo")
    }
    Goto home
    
    //	Da considerare alla fine di State home e State ashout:
    // 	se il contenitore WasteStorage non è vuoto, il contenitore AshStorage non è pieno e 
	//	l'inceneritore non è in fase di combustione, passare alla porta WASTEIN. 
	//	Se una delle condizioni non è vera, attendere a HOME finché non diventa vera.

    State home {
        println("Robot in home position")
    }
    Transition t0 whenEvent burnEnd -> burnout
    //Transition t0 whenMsg go -> wastein
    //				whenMsg go -> burnout
 
    
    //	messaggio di transizione da home a WASTEIN o da home a BURNOUT
    //	ancora da definire il mittente ed il tipo di messaggio 
    //	in quanto non è specificato dal committente 
	
    State wastein {
        println("OpRobot: prelievo roll packets da WASTEIN") color green
    }Goto burnin

    State burnin {
        println("OpRobot: deposito roll packets nella porta BURNIN") color green
    }Goto home

    State burnout {
        println("OpRobot: prelievo cenere dalla porta BURNOUT") color green
    }Goto ashout

    State ashout {
        println("OpRobot: deposito cenere nella porta ASHOUT") color green
    }
    //Transition t0 whenMsg go -> wastein 
    //				whenMsg go -> home
	
	//	messaggio di transizione da ASHOUT a home o da ASHOUT a WASTEIN
    //	ancora da definire il mittente ed il tipo di messaggio 
    //	in quanto non è specificato dal committente
}






//--------------------------Incinerator-----------------------------

QActor incinerator context ctxwis {
    [#val BTIME = 100L#]

    State s0 initial {
        printCurrentMessage
        println("Incinerator: initialized") color green
    }
    //Transition t0 whenMsg cmd -> idle
    //	messaggio di transizione da iniziale a idle;
    //	ancora da definire il mittente ed il tipo di messaggio 
    //	in quanto non è specificato dal committente

    State idle {
        println("Incinerator: idle") color green
    }
    //	non è ancora chiaro come passare dallo stato idle
    //	a quello On in quanto non è chiaramente specificato
    //	dal committente
    
    State on {
        println("Incinerator: burning") color green
		//simulazione del processo di incenerimento
		[#delay BTIME*1000#]
        emit burnEnd : burnEnd(BTIME)
    }
   	Goto idle
}

QActor scale context ctxscale {
	State s0 initial {
        printCurrentMessage
        println("Scale: initialized") color green
    }
}
	
QActor sonar context ctxsonar {
	State s0 initial {
        printCurrentMessage
        println("Sonar: initialized") color green
    }
}